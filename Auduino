#include <Wire.h>
#include <SparkFun_MMA8452Q.h>
#include <Stepper.h>
#include <NimBLEDevice.h>

// æ­¥è¿›ç”µæœºå‚æ•°
const int stepsPerRevolution = 2038;
Stepper myStepper(stepsPerRevolution, 4, 2, 5, 3);

// åŠ é€Ÿåº¦è®¡
MMA8452Q accel;

// ç¼–ç å™¨å¼•è„šä¸å˜é‡
const int encoderCLK = 18;
const int encoderDT  = 19;
volatile int encoderPos = 0;
int lastCLK = 0;

// BLE UUID
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcdefab-1234-1234-1234-abcdefabcdef"

NimBLECharacteristic* pCharacteristic;
bool motorEnabled = false;
bool clientConnected = false;
bool systemEnabled = false;

// ç¼–ç å™¨ä¸­æ–­å¤„ç†



// æ¥æ”¶ BLE æ•°æ®å¤„ç†
class DataReceiveCallback : public NimBLECharacteristicCallbacks {
  void onWrite(NimBLECharacteristic* pChar) {
    std::string val = pChar->getValue();
    String cmd = String(val.c_str());
    cmd.trim(); cmd.toUpperCase();

    Serial.print("ğŸ“© BLE Command Received: ");
    Serial.println(cmd);

    if (cmd == "START") {
      systemEnabled = true;
      motorEnabled = true;
      Serial.println("âœ… System + Motor ENABLED");
    } else if (cmd == "STOP") {
      systemEnabled = false;
      motorEnabled = false;
      Serial.println("ğŸ›‘ System + Motor DISABLED");
    }
  }
};

// BLE è¿æ¥çŠ¶æ€å›è°ƒ
class ServerCallbacks : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* pServer) {
    Serial.println("âœ… BLE client connected");
    clientConnected = true;
  }
  void onDisconnect(NimBLEServer* pServer) {
    Serial.println("âŒ BLE client disconnected");
    clientConnected = false;
    NimBLEDevice::startAdvertising();
  }
};

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("ğŸ”§ System Starting...");

  // åˆå§‹åŒ–åŠ é€Ÿåº¦è®¡
  Wire.begin(6, 7);  // SDA=6, SCL=7
  if (!accel.begin()) {
    Serial.println("âŒ MMA8452Q not detected");
    while (1);
  }
  accel.setScale(SCALE_2G);
  accel.setDataRate(ODR_100);
  Serial.println("âœ… MMA8452Q initialized");

  // åˆå§‹åŒ–æ­¥è¿›ç”µæœº
  myStepper.setSpeed(100);

  // åˆå§‹åŒ–ç¼–ç å™¨
  pinMode(encoderCLK, INPUT_PULLUP);
  pinMode(encoderDT, INPUT_PULLUP);
  lastCLK = digitalRead(encoderCLK);
  Serial.println("âœ… Encoder initialized");

  // åˆå§‹åŒ– BLE
  NimBLEDevice::init("ESP32C3-MotorBLE");  // âœ… è®¾ç½®è®¾å¤‡åç§°
  NimBLEServer* pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  NimBLEService* pService = pServer->createService(SERVICE_UUID);
  pCharacteristic = pService->createCharacteristic(
  CHARACTERISTIC_UUID,
  NIMBLE_PROPERTY::WRITE |
  NIMBLE_PROPERTY::WRITE_NR |
  NIMBLE_PROPERTY::READ |
  NIMBLE_PROPERTY::NOTIFY
  );
  pCharacteristic->setCallbacks(new DataReceiveCallback());
  pCharacteristic->setValue("READY");
  pService->start();

  // è®¾ç½® BLE å¹¿æ’­å¹¶æ·»åŠ è®¾å¤‡åä½œä¸º scan response
  NimBLEAdvertising* pAdv = NimBLEDevice::getAdvertising();
  pAdv->addServiceUUID(SERVICE_UUID);
  pAdv->setAppearance(0x00);

NimBLEAdvertisementData scanResponseData;
scanResponseData.setName("ESP32C3-MotorBLE");
pAdv->setScanResponseData(scanResponseData);
pAdv->enableScanResponse(true);

  pAdv->start();
  Serial.println("ğŸ“¡ BLE advertising started");
  Serial.flush();

}

void loop() {
  static float lastX = 0, lastY = 0, lastZ = 0;
  static int lastEncoder = 0;
  static unsigned long lastLoopTime = 0;
  static unsigned long lastNotifyTime = 0;
  const unsigned long notifyInterval = 1000; // æœ€å¿«æ¯ç§’é€šçŸ¥ä¸€æ¬¡ BLE
  const unsigned long loopInterval = 500;    // æ¯ 500ms æ‰§è¡Œä¸€æ¬¡åˆ¤æ–­é€»è¾‘

  // âŒ¨ï¸ Serial å‘½ä»¤è¾“å…¥
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim(); cmd.toUpperCase();

    Serial.print("ğŸ§ª Serial Command: ");
    Serial.println(cmd);

    if (cmd == "START") {
      systemEnabled = true;
      motorEnabled = true;
      Serial.println("âœ… System + Motor ENABLED via Serial");
    } else if (cmd == "STOP") {
      systemEnabled = false;
      motorEnabled = false;
      Serial.println("ğŸ›‘ System + Motor DISABLED via Serial");
    }
  }

  if (!systemEnabled) return;

  // === ç¼–ç å™¨è½®è¯¢è¯»å– ===
  int clkState = digitalRead(encoderCLK);
  int dtState  = digitalRead(encoderDT);
  if (clkState != lastCLK) {
    if (dtState != clkState) encoderPos++;
    else encoderPos--;
    lastCLK = clkState;
  }

  unsigned long currentTime = millis();
  if (currentTime - lastLoopTime < loopInterval) return;
  lastLoopTime = currentTime;

  // ğŸ§­ åŠ é€Ÿåº¦è®¡è¯»å–
  accel.read();
  float x = accel.x;
  float y = accel.y;
  float z = accel.z;

  // ğŸ” è¯»å–ç¼–ç å™¨å½“å‰å€¼
  int currentEncoder = encoderPos;

  // æ˜¯å¦æœ‰å˜åŒ–
  bool orientationChanged = abs(x - lastX) > 0.2 ||
                            abs(y - lastY) > 0.2 ||
                            abs(z - lastZ) > 0.2;
  bool encoderChanged = (currentEncoder != lastEncoder);

  if ((orientationChanged || encoderChanged) &&
      (currentTime - lastNotifyTime > notifyInterval)) {

    lastX = x;
    lastY = y;
    lastZ = z;
    lastEncoder = currentEncoder;
    lastNotifyTime = currentTime;

    Serial.print("Accel -> X: ");
    Serial.print(x);
    Serial.print(" | Y: ");
    Serial.print(y);
    Serial.print(" | Z: ");
    Serial.print(z);
    Serial.print(" || Encoder: ");
    Serial.println(currentEncoder);

    // BLE é€šçŸ¥å‘é€
    if (clientConnected) {
      String payload = "X:" + String(x, 2) +
                       " Y:" + String(y, 2) +
                       " Z:" + String(z, 2) +
                       " ENC:" + String(currentEncoder);
      pCharacteristic->setValue(payload.c_str());
      pCharacteristic->notify();
    }

    // ç”µæœºæ§åˆ¶é€»è¾‘
    if (motorEnabled) {
      if (x > 0.5) {
        myStepper.step(50);
        Serial.println("â†» CW step");
      } else if (x < -0.5) {
        myStepper.step(-50);
        Serial.println("â†º CCW step");
      }
    }
  }
}
